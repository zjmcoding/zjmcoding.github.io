{"pages":[],"posts":[{"title":"","date":"2019-07-27T07:37:17.238Z","path":"2019/07/27/Linux/","text":"","link":"","tags":[]},{"title":"","date":"2019-07-24T10:24:44.421Z","path":"2019/07/24/Redis/","text":"","link":"","tags":[]},{"title":"Leetcode","date":"2019-06-15T14:38:10.000Z","path":"2019/06/15/LeetCode刷题/","text":"LeetCode 5312345678910111213141516171819202122232425262728293031323334353637383940/*** 蛮力法解决方法 @author zjmcoding @version 1.0*/class Solution &#123; public int maxSubArray(int[], nums) &#123; //最大和的连续子数组 int max = Integer.MIN_VALUE; /* 初始化，对最大值附一个系统中的最小值*/ int sum = 1; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = i; j &lt; nums.length; ++i) &#123; sum += nums[j]; if (sum &gt; max) max = sum; &#125; &#125; return max; &#125;&#125;/*** 当我们发现蛮力法的时间复杂度太高,我们可以尝试将复杂度降到O(n),如何降至O(n)呢？ 我们可以考虑在蛮力法的基础上考虑改进，去掉一些不必要的重复，例如数组中连续子数组 之和小于0，则对于后续的数组累加没有贡献，我们则可以考虑直接去掉跳过重复计算小于零的部分。 @author zjmcoding @version 2.0*/class Solution &#123; public int maxSubArray(int[], nums) &#123; //最大和的连续子数组 int max = Integer.MIN_VALUE; /* 初始化，对最大值附一个系统中的最小值*/ int sum = 0; //初始化，sum 赋值为零 for (int i = 0; i &lt; nums.length; ++i) &#123; //对数组中的元素访问一遍，时间复杂度O(n) if (sum &lt; 0) //如果 sum 的值小于零，那么它对于后续的加法没有贡献，因此直接赋值为零 sum = 0; sum += nums[i]; // 对数组中的元素依次累加 if (sum &gt; max) // 如果当前的连续子数组的和大于最大值，则更新最大值。 max = sum; &#125; return max; &#125;&#125; LeetCode 1521234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 蛮力法解决方法 @author zjmcoding @version 1.0*/class Solution &#123; public int maxProduct(int[] nums) &#123; //最大积的连续子数组 int max = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; ++i) &#123; int multiply = 1; for (int j = i; j &lt; nums.length; ++j) &#123; multiply *= nums[j]; if (multiply &gt; max) max = multiply; &#125; &#125; return max; &#125;&#125;/*** 蛮力法的时间复杂度太高，我们考虑改进 @author zjmcoding @version 2.0*/class Solution &#123; public int maxProduct(int[] nums) &#123; //最大积的连续子数组 int max = Integer.MIN_VALUE; int imin = 1, imax = 1; //初始化两个变量分别记录当前的最大值与最小值 for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] &lt; 0) &#123; // 当遇见负数时，最大值变为最小值，最小值变为最大值，因此交换两个值 tmp = imax; imax = imin; imin = tmp; &#125; imax = Math.max(imax * nums[i], nums[i]); //记录当前最大值 imin = Math.min(imin * nums[i], nums[i]); //记录当前最小值 max = Math.max(max, imax); // 比较最大值与当前最大值并保存最大值 &#125; return max; &#125;&#125; LeetCode 97812345678910111213141516171819202122232425262728293031323334/*** 对于这个问题，首先我们必须读懂问题，其实这个问题本质上是找出来一个符号连续变化的子数组 @author wangzi6147 @version 2.0*/class Solution &#123; public int maxTurbulenceSize(int[] A) &#123; //最大湍流连续子序列 /*初始化，inc 表示当前元素相对于前一个元素增加, 即 &gt; dec 表示当前元素相对于前一个元素减少，即 &lt; result 表示最大湍流连续子数组长度。 */ int inc = 1, dec = 1, result = 1; for (int i = 1; i &lt; A.length; ++i) &#123; if (A[i] &lt; A[i-1]) &#123; //当前元素的值小于前一个元素 dec = inc + 1; //那么小于号的关联的元素个数等于inc + 1 inc = 1; //此时，inc 的个数赋值为 1 &#125; else if (A[i] &gt; A[i-1]) &#123; inc = dec + 1; dec = 1; &#125; else &#123; // 也就是当前元素与前一个元素相等时，丢弃之前dec inc 的值，重新开始寻找最大湍流连续子序列。 dec = 1; inc = 1; &#125; result = Math.max(result, Math.max(dec, inc)); //输出最大的湍流连续子序列长度。 &#125; return result; &#125;&#125;","link":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"机器学习引言","date":"2019-05-26T02:56:07.000Z","path":"2019/05/26/机器学习概述/","text":"机器学习引言What is Machine Learning？（机器学习是什么？）Tom Mitchell: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. 一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P, 当且仅当，有了经验E后，经过P评判，程序在处理T时性能有所提升。 Supervised Learning（监督学习）监督学习指的就是我们给学习算法一个数据集，这个数据集由“正确答案”组成。分类classification和回归regression Unsupervised Learning数据没有标签，聚类 单变量线性回归 Linear Regression with One Variable把训练集喂给学习算法，学习算法工作了，然后输出一个函数，通常表示为小写h。 h代表Hypothesis, h表示一个函数，h根据输入x值来得出y值，h 是一个从 x 到 y 的函数映射。 一种可能的表达方式为：$h_\\theta(x) = \\theta_0 + \\theta_1x$, 只含有一个特征/输入变量，单变量线性回归。","link":"","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"线性表","date":"2019-05-13T12:30:07.000Z","path":"2019/05/13/Python数据结构/","text":"线性表一个线性表是n个数据元素的有限序列。 一个数据元素可以由若干个数据项(item)组成。 这种情况下，数据元素称为记录(record), 含有大量记录的线性表又称文件(File)。线性表的基本操作： Initiate(L) 初始化操作 Length(L) 求线性表的长度 Get(L) 取线性表中的元素 Prior(L,elm) 求线性表中给定元素的前驱 Next(L,elm) 求线性表中给定元素的后继 Locate(L,x) 查找给定元素在线性表中的位置 Insert(L,i,b) 在线性表L中第i个数据元素之前插入一个新的元素b Delete(L,i) 删除线性表中第i个数据元素 Empty(L) 判断线性表是否为空 Clear(L) 将线性表置空较复杂的操作：如合并两个线性表 12345678class ListUnion: \"\"\"docstring for ListUnion\"\"\" def listUnion(self, L1, L2): #L = list(set(L1) | set(L2)) for i in L2: if i not in L1: L1.append(i) return L1 线性表的顺序存储结构","link":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Leetcode","date":"2019-05-13T12:30:07.000Z","path":"2019/05/13/LeetCodeFistDay/","text":"题目一123456789101112131415161718192021\"\"\"Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].\"\"\"class Solution1: \"\"\"docstring for towSum\"\"\" def twoSum(self, nums, target): d = &#123;&#125; #用于存储nums中已经访问过的数字 for i in range(len(nums)): if target - nums[i] in d: return [d[target - nums[i]], i] else: d[nums[i]] = i#Brute Force def twoSum_BF(self, nums, target): lenNums = len(nums) for i in range(lenNums): for j in range(i,lenNums): if nums[i] + nums[j] == target: return [i,j] 题目二1234567891011121314151617181920212223\"\"\"Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.\"\"\" class ListNode: def __init__(self, x): self.val = x self.next = Noneclass solution2: def addTwoNumbers(self, l1, l2): carry = 0 root = n = ListNode(0) while l1 or l2 or carry: if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next","link":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"如何搭建自己的个人博客","date":"2019-05-01T08:32:27.000Z","path":"2019/05/01/如何搭建自己的个人博客/","text":"总共分为三部分： 搭建github Pages 安装Hexo 部署(Deploy)到Github 搭建github Pages网上教程很多，这一步掠过(hahaha) 安装Hexo下载安装node.js如图所示： 下载安装Git如图所示： 接下来很关键，在自己的电脑本地建一个文件夹，可以自己命名(如Blog,Hexo),例如E:\\Blog, 然后在Blog文件夹下右击鼠标选择Git Bash Here(我们打开了一个Git窗口)。 紧接着，我们的操作都要在这个窗口中进行。1234567$ node -v (查看nodejs版本信息，一般不会有问题)$ npm -v (产看npm版本)$ npm install hexo-cli -g (安装Hexo)$ hexo init (初始化网站)$ npm install$ hexo generate (生成或者hexo g)$ hexo s (启动本地服务器) 两个常用命令：12$ hexo new \"文章名\" （新建文章）$ hexo new page \"页面名\" 添加主题：12$ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 启动主题：找到目录下的_config.yml文件，找到theme并设置为 theme: yilia更新主题：1234$ cd theme/yilia$ git pull$ hexo g$ hexo s 使用hexo deploy 部署到GitHub编辑根目录下的_config.yml文件.1234deploy: type: git repo: git@github.com:cczeng/cczeng.github.io.git #这里的网址填你自己的SSH地址 branch: master 保存后安装hexo d扩展：1$npm install hexo-deployer-git --save 添加SSH Key到Github(网上有很多类似的教程)测试是否添加成功：1$ ssh -T git@github.com 设置账号信息：12$ git config --global user.name \"jingmingzhang\"$ git config --global user.email \" 50131458+zjmcoding@users.noreply.github.com\" 根据自身GitHub账号修改。 部署到GitHub1$ hexo d 收工回家休息（哈哈哈），对了告诉一下你，如何你在本地对文件进行了修改，或者添加了新的博客页面，执行一下命令就可以了。123$ hexo clean$ hexo generate$ hexo d","link":"","tags":[{"name":"Hexo + Github","slug":"Hexo-Github","permalink":"http://yoursite.com/tags/Hexo-Github/"}]},{"title":"我的第一篇博客","date":"2019-04-30T12:30:07.000Z","path":"2019/04/30/我的第一篇博客/","text":"四月的最后一天今天是四月的最后一天，我搭建了自己的个人博客很开心!! 记得写博客以后的日子里，每一天，我都要学会写Blog, 一定要学会坚持。 记得和小素庆祝每一天你们两个人在一起便是上天的缘分，要好好珍惜，不要让素素悲伤。","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"超级思维","date":"2019-04-30T12:30:07.000Z","path":"2019/04/30/超级思维/","text":"把别人的思维变成自己的工具万丈高楼平地起成功就是把不可能变成可能 价值观向善：永远怀有利他之心简单：有话直说，敢想敢做生猛：没有什么不可失去，唯有自信和强大不可失去疼痛：任何成长都伴随着疼痛，痛并快乐着意义感：看到事物的意义感，看到更多的可能性，感到生命的意义感 找好理由，公司企业文化比较历练，我的性格比较外向立场坚定","link":"","tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"}]},{"title":"Python","date":"2019-04-30T12:30:07.000Z","path":"2019/04/30/明明学Python/","text":"Python基础语法Python基本语法一、 注释 #注释内容 三引号注释内容： ‘’’注释内容’’’二、 标识符命名及变量命名首字母是字母下划线，除首字母之外，可以是数字、字母、下划线（标志符）。三、 Python中常见的数据类型123456789101112131415161718192021\"\"\"数、字符串、列表(list)、元祖(tuple)、集合、字典\"\"\"a1='abc'a2=\"abc\"a3=\"\"\"abc\"\"\"#存储多个元素的东西b = [7,'cd','ef',4,]b[1]b[0] = 'abcd'#列表中的元素是可以替换的\"\"\"元组：存储多个元素的东西，但是元组中的元素是不能替换的tuple does not support item assignment\"\"\"#字典#&#123;key:value,key:value,......&#125;c = &#123;I:1,L:0,Y:0,O:0,'!':0&#125;d = &#123;'name':'zhangjingming','job':'student', 'sex':'boy'&#125;#集合：去重e = set(\"jksldjfsdhhhhllj\")f = set(\"jldsfjshdfosdfih\")g = e - f #集合的差集h = e + f #集合的并集#运算符， +、-、*、/、 %等；注意+可以用于字符串连接 Python的控制流 顺序结构 条件分支结构 循环结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#if语句a = 10000if (a &gt; 10): print(\"I love you, Python!\") if a &gt; 100: print(\"I believe I can do it！\")elif(a &gt; 10 and a &lt;100): print(\"you will do it!\")else: print(\"Just do it !\")#whilea = 0while(a &lt; 10): a += 1 print(\"Just do it!\")#for:遍历列表a = ['I','love','python']for i in a: print(i)#for:进行常规循环for i in range(1,11): print(i)#continue,break#break:全部直接退出a = ['I','love','python']for i in a: if i == 'love': break print(i)#continue:中断一次循环，继续下一次循环a = ['I','love','python']for i in a: if i == 'love': break print(i)#循环输出乘法口诀表# end=\"\" 表示不换行输出for i in range(1,10): for j in range(1,i+1): print(str(i)+\"*\"+str(j)+\"=\"+str(i*j), end = \" \") print()#乘法口诀表的逆向输出for i in range(1,10): for j in range(i,10): print(str(10-i)+\"*\"+str(10 -j)+\"=\"+str((10-i)*(10 -j)), end = \" \") print()for i in range(1,10): for j in range(i,10): print(str(10-i)+\"*\"+str(10 -j)+\"=\"+str((10-i)*(10 -j)), end = \" \") print() print(i*\" \",end = \"\") for i in range(9,0,-1): for j in range(i,0,-1): print(str(i)+\"*\"+str(j)+\"=\"+str(i*j), end = \" \") print() Python函数详解12345678910111213141516171819202122232425#函数的本质就是功能的封装。使用函数可以大大提高编程的效率与程序的可读性。#变量是有生效范围的，生效范围称为作用域。局部变量与全局变量#作用域\"\"\"i = 10def func(): j = 10 print(j)print(i) #i是全局变量print(j) #j是局部变量，出错func()\"\"\"#函数def abc(): print(\"abcdefg\")#调用函数：函数名(参数)abc()#参数： 与外界沟通的接口#参数： 形参和实参#一般在函数定义的时候使用的参数是形参#一般的函数调用时使用的参数是实参def func2(a,b): if(a &gt; b): print(\"&#123;&#125; &gt; &#123;&#125;\".format(a,b)) else: print(\"&#123;&#125; &lt;= &#123;&#125;\".format(a,b))func2(2,4) Python模块模块是功能块(函数)的集合，功能块是代码块的集合 123456789\"\"\"模块的导入 from ... import ...模块的类别（来源）：1. 自带模块 2.第三方模块 3. 自定义模块第三方模块安装：1. pip安装 2. whl安装（https://www.lfd.uci.edu/~gohlke/pythonlibs/) pip install 文件名.whl3. 直接复制到lib目录下（python版本对应，操作系统对应）自定义模块：在lib中自定义自己的模块\"\"\" Python文件操作12345678910#文件操作#文件打开#open(文件地址，操作形式)f = open(\"D:/filepath\",'r',encoding=\"utf-8\")data = f.read()line = f.readline()f.close()#文件关闭f2 = open(\"D:/filepath\",'w')f2.write(data)f2.close() Python异常处理12345678910111213141516171819202122232425#异常处理#异常处理格式\"\"\"try: 程序except Exception as 异常名称： 异常处理部分\"\"\"try: for i in range(0,10): print(i) if (i = 4): print(ijk) print(\"hello\")except Exception as err: print(err)#让异常后的程序继续执行for i in range(0,10): try: print(i) if (i = 4): print(ijk) except Exception as err: print(err)print(\"hello\") Python面向对象编程（OOP编程）类和对象类：具有某种特征的事物的集合（群体）对象：群体（类）里面的个体类是抽象的，对象是具体的。（类的实例化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071\"\"\"class 类名： 类里面的内容a(对象) = 类名（）（类的实例化）\"\"\"#构造函数（构造方法）#self: 在类中定义的方法必须加上self参数#__init__(self,参数)#构造函数实际意义：初始化class cl1: def __init___(self): print(\"I am a big man!\")#给类加上参数：给构造方法加上参数class cl2: def __init___(self,name,job): print(\"I am \" + name + \"My job is \"+ job)#属性：静态的特征。如头发、手臂等。类里面的变量#方法：动态的特征。 如跳舞，唱歌等。class cl3: def __init__(self,name,job): self.myname = name self.myname = job print(\"I am \" + self.myname + \"My job is \"+ self.myname)#方法： 类里面的函数。def 方法名（self,参数）class cl4: def myfunction(self, name): print(\"hello \"+ name)c = cl4() #类的实例化c.myfunction(\"zhangjingming\")class cl6: def __init__(self,name,job): self.myname = name self.myjob = job def myfunction(self): print(\"hello \"+ self.myname + \" your job is \"+ self.myjob)c = cl6(\"Jingming\",\"Master\")c.myfunction()#继承：把一个或多个类（基类）的特征拿过来。#重载：在子类（派生类）里面对继承过来的特征重新定义#父类：基类#子类：派生类#继承：单继承（父类只有一个） 多继承（继承了多个父类）#父亲，母亲，女儿，儿子1，儿子2，父亲可以说话，母亲可以写字，儿子1继承父亲#女儿继承了父亲，也继承了母亲#儿子2继承了父亲，但是优化或者减弱了父亲的说话能力##父亲（基类）class father(): def speak(self): print(\"I can speak!\")#单继承： class 子类（父类）class son(father): pass#母亲类（基类）class mother(): \"\"\"docstring for ClassName\"\"\" def write(self): print(\"I can write!\")#多继承： class 子类（父类1，父类2，...)class daughter(father,mother): def listen(self): print(\"I can listen!\") 第一天12345678910111213141516171819202122232425262728293031323334353637383940import this\"\"\"The Zen of Python, by Tim PetersBeautiful is better than ugly.优美胜于丑陋（Python 以编写优美的代码为目标）Explicit is better than implicit.明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex.简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated.复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested.扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense.间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）Readability(可读性) counts.可读性很重要（优美的代码是可读的）Special cases(特例) aren't special enough to break the rules.即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）Although practicality beats purity.（尽管实用性很重要，但绝没有纯洁性重要）Errors should never pass silently(绝不让错误悄无声息地通过).Unless explicitly silenced.不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）In the face of ambiguity, refuse the temptation(诱惑) to guess.当存在多种可能，不要尝试去猜测There should be one -- and preferably only one --obvious way to do it.而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）Although that way may not be obvious at first unless you're Dutch(可能这种方法一开始不够直接，因为你不是范罗苏姆, Python之父).虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido）Now is better than never.做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\"\"\"","link":"","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","date":"2019-04-30T12:23:53.254Z","path":"2019/04/30/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[]}]}